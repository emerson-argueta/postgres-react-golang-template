package jwt

import (
	"emersonargueta/m/v1/authorization"
	"time"

	"github.com/dgrijalva/jwt-go"
)

const (
	// AccestokenLimit represents the expiration time for an access token
	AccestokenLimit = time.Minute * 15
	// RefreshtokenLimit represents the expiration time for an refresh token
	RefreshtokenLimit = time.Hour * 24
)

var _ authorization.Processes = &service{}

type service struct {
	client *Client
}

// TokenPair represents the access token for authentication and refresh token to
// refresh access, both as strings.
type TokenPair struct {
	Accesstoken  string `json:"accesstoken,omitempty"`
	Refreshtoken string `json:"refreshtoken,omitempty"`
}

// TokenPairJWT represents the access token for authentication and refresh token to
// refresh access, both as jwt.Token.
type TokenPairJWT struct {
	Accesstoken  *jwt.Token `json:"accesstoken,omitempty"`
	Refreshtoken *jwt.Token `json:"refreshtoken,omitempty"`
}

// Authorize a user where the key is a jwt token. Returns the user's uuid if succesful,or ErrAuthorizationFailed
func (s *service) Authorize(key interface{}) (res *string, e error) {
	jwtToken, ok := key.(*jwt.Token)
	if !ok {
		return nil, ErrJWTAuth
	}
	uuid, ok := jwtToken.Claims.(jwt.MapClaims)["uuid"].(string)
	if !ok {
		return nil, authorization.ErrAuthorizationFailed
	}

	res = &uuid

	return res, nil
}
func (s *service) NewKey(uuid string) (res map[string]string, e error) {
	tokenPair, e := s.generateTokenPair(uuid)
	if e != nil {
		return nil, authorization.ErrAuthorizationKeyNotCreated
	}

	res = make(map[string]string)
	res["accesstoken"] = tokenPair.Accesstoken
	res["refreshtoken"] = tokenPair.Refreshtoken

	return res, e
}

// NewToken for a user is generated by checking uuid parameter to the uuid extracted from the
// token cliams, if matching then generates a valid token and issues a new token
// pair to that user.
func (s *service) NewToken(token *TokenPair, uuid string) (res *TokenPair, e error) {

	// Validate refresh token
	if jwtTokenPair, err := s.tokenPairStringToJWT(token); err != nil {
		return nil, ErrJWTAuth
	} else if uuidClaim, ok := jwtTokenPair.Refreshtoken.Claims.(jwt.MapClaims)["uuid"].(string); !ok {
		return nil, ErrJWTAuth
	} else if uuidClaim != uuid {
		return nil, ErrJWTAuth
	} else if tokenPair, err := s.generateTokenPair(uuid); err != nil {
		return nil, err
	} else {

		res = tokenPair
	}
	return res, nil
}

// TokenPairStringToJWT converts a string access and resfresh token from a TokenPair
// to a TokenPairJWT.
func (s *service) tokenPairStringToJWT(token *TokenPair) (res *TokenPairJWT, e error) {
	atk, err := jwt.ParseWithClaims(
		token.Accesstoken,
		jwt.MapClaims{},
		func(token *jwt.Token) (interface{}, error) {
			return []byte(s.client.config.Authorization.Secret), nil
		},
	)
	if err != nil && err.(*jwt.ValidationError).Errors != jwt.ValidationErrorExpired {
		return nil, err
	}

	rtk, err := jwt.ParseWithClaims(
		token.Refreshtoken,
		jwt.MapClaims{},
		func(token *jwt.Token) (interface{}, error) {
			return []byte(s.client.config.Authorization.Secret), nil
		},
	)
	if err != nil && err.(*jwt.ValidationError).Errors == jwt.ValidationErrorExpired {
		return nil, ErrRefreshTokenExpired
	} else if err != nil {
		return nil, err
	}

	res = &TokenPairJWT{Accesstoken: atk, Refreshtoken: rtk}
	return res, err
}

// GenerateTokenPair creates a token pair which contains access token and
// refresh token with exp limit for both access and refresh token.
func (s *service) generateTokenPair(uuid string) (*TokenPair, error) {
	accessToken := jwt.New(jwt.SigningMethodHS256)

	atclaims := accessToken.Claims.(jwt.MapClaims)
	atclaims["uuid"] = uuid
	atclaims["exp"] = time.Now().Add(AccestokenLimit).Unix()

	// Generate encoded accessToken.
	atstr, err := accessToken.SignedString([]byte(s.client.config.Authorization.Secret))
	if err != nil {
		return nil, err
	}

	refreshToken := jwt.New(jwt.SigningMethodHS256)

	rtClaims := refreshToken.Claims.(jwt.MapClaims)
	rtClaims["uuid"] = uuid
	rtClaims["exp"] = time.Now().Add(RefreshtokenLimit).Unix()

	// Generate encoded refreshToken.
	rtstr, err := refreshToken.SignedString([]byte(s.client.config.Authorization.Secret))
	if err != nil {
		return nil, err
	}

	return &TokenPair{Accesstoken: atstr, Refreshtoken: rtstr}, nil
}
