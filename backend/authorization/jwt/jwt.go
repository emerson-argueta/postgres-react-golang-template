package jwt

import (
	"emersonargueta/m/v1/authorization"
	"emersonargueta/m/v1/delivery/middleware"

	"github.com/dgrijalva/jwt-go"
)

var _ authorization.Processes = &Service{}

// Service for jwt authentication.
type Service struct {
	client     *Client
	middleware *middleware.Middleware
}

// Authorize a user where the key is a jwt token. Returns the user's uuid if succesful,or ErrAuthorizationFailed
func (s *Service) Authorize(key interface{}) (res *string, e error) {
	jwtToken, ok := key.(*jwt.Token)
	if !ok {
		return nil, ErrJWTAuth
	}
	uuid, ok := jwtToken.Claims.(jwt.MapClaims)["uuid"].(string)
	if !ok {
		return nil, authorization.ErrAuthorizationFailed
	}

	res = &uuid

	return res, nil
}

// NewToken for a user is generated by checking uuid parameter to the uuid extracted from the
// token cliams, if matching then generates a valid token and issues a new token
// pair to that user.
func (s *Service) newToken(token *middleware.TokenPair, uuid string) (res *middleware.TokenPair, e error) {

	// Validate refresh token
	if jwtTokenPair, err := s.middleware.TokenPairStringToJWT(token); err != nil {
		return nil, ErrJWTAuth
	} else if uuidClaim, ok := jwtTokenPair.Refreshtoken.Claims.(jwt.MapClaims)["uuid"].(string); !ok {
		return nil, ErrJWTAuth
	} else if uuidClaim != uuid {
		return nil, ErrJWTAuth
	} else if tokenPair, err := s.middleware.GenerateTokenPair(uuid, middleware.AccestokenLimit, middleware.RefreshtokenLimit); err != nil {
		return nil, err
	} else {

		res = tokenPair
	}
	return res, nil
}
